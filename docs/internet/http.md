# HTTP 那些事

## 1. HTTP 请求模型

HTTP 请求模型中分成 client 端和 server 端，client 端和 server 端 如何区分，就看请求的状态，如果是发起请求，那就是 client 端，如果是接收请求就是 server 端。

比如我们将 node 和前端放一起，使用 node 做中间件，那 node 相对于前端来说是 server 端，但是 node 如果相对于其他服务端，比如相对于 java 来说，node 就是 client 端。

## 2. 输入网址之后发生了什么

用户在输入网址之后，为什么可以得到相应域名对应的页面呢，其实后续发生了很多隐藏的行为：

1. 用户输入域名确定之后，通过 DNS 解析域名，将域名解析出对应的 IP（如果连续向同一个域名发送请求，DNS 只会解析一次域名，会将域名和 IP 的映射关系进行缓存）。
2. 浏览器向对应的 IP 发送请求，在通信过程中，通过中继器（路由器）将请求持续转发，一直转发到指定的 IP。
3. 一个 IP 可能对应一个集群或者一个机房，通过反向代理服务器做的负载均衡分配给某个服务器去处理用户请求。
4. 服务器将资源进行返回。
5. 浏览器处理 html 及其他静态资源，渲染给用户。

## 3. HTTP 协议

HTTP 协议主要对客户机到服务器请求（Request）和服务器到客户机的请求（Response）进行约束和规范。

HTTP 协议中有两种协议栈，主要分为 `ISO/OSI` 和 `TCP/IP` 两种协议栈。

### 3.1 TCP/IP 协议栈

目前大多数使用的一般都是 `TCP/IP` 协议，`TCP/IP` 协议其中包含四层网络分层：应用层，传输层，网络层，网络接口层。

`TCP/IP` 协议栈对应用层划分不细致，所以就导致了 HTTP 协议不能保存会话。

- 应用层

应用层是和代码直接接触的网络协议层，其中包含了很多协议，包括 `HTTP` 协议，`SSH` 协议，`DNS` 协议，发送邮件的 `SMTP` 协议，接受邮件的 `POP` 协议，文件传输协议 `FTP` 等。

- 传输层

传输层直接和应用层进行打交道，对上层应用层提供网络连接中两台计算机之间的数据传输，其中包括主要的两个协议：`TCP` 协议和 `UDP` 协议。

`TCP`（传输控制协议），可靠协议，`UDP`（用户数据报协议），不可靠协议，只管发送。

- 网络层

网络层用来处理网络上流动的数据包，当对方计算机中包含多台计算机时，会从众多计算机中选择其中一条传输路线。

`IP` 就属于网络层。

当我们在命令行中使用 `ping www.baidu.com` 时，其实就执行在网络层，使用了 ICMP 数据报文去检测当前 `ping` 的域名是否能 `ping` 通，对应的 `IP` 具体是什么。

- 网络接口层

数据链路层主要是一些用来处理连接网络的硬件部分，包括：网卡，交换机，操作系统等硬件设备。

### 3.2 IOS/OSI 协议栈

还有一种协议栈是 `IOS/OSI`，`IOS/OSI` 协议栈分层会比 `TCP/IP` 协议栈分层更详细，分为七层：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。

`IOS/OSI` 协议栈的分层，其实是将 `TCP/IP` 协议栈中的应用层和网络接口层划分的更细了，将应用层划分成了应用层，表示层，会话层，将网络接口层划分成了数据链路层，物理层。

### 3.3 IP、TCP、DNS

IP 与 IP 地址不同，IP 是传输数据包用的协议，IP 包含 IP 地址和 MAC 地址。

IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以与 MAC 地址进行配对，IP 地址可更换，MAC 地址一般不会改变。

**TCP 三次握手**：TCP -> SYN -> ACK

- 发送端首先发送一个带有 SYN 的数据包给对方
- 接收端回传一个带有 SYN/ACK 标志的数据包表示确认消息
- 发送端再回传一个 ACK 标志的数据包，表示“握手”结束

DNS 服务提供域名到 IP 地址之间的解析服务。

## 4. HTTP 工作流程

### 4.1 工作流程

一次 HTTP 工作流程，属于一个事务，如果一个过程失败了，那就会失败。

HTTP 工作流程主要分为以下四步：

1. 客户机需要和服务器建连，当用户输入一个网址敲回车之后，HTTP 就开始工作了，首先让客户机和服务器建连。
2. 建连之后，客户机向服务器发出请求（Request），其中包括请求行，请求报头，请求正文。
3. 服务器接受到请求信息之后，对请求信息进行处理，然后给客户机返回信息，返回的信息中包括状态行，响应报头，响应正文。
4. 客户机对服务器返回回来的信息做处理，并进行展示。

> URI 和 URL 的区别，URI 指的是资源真正的路径，URL 不一定是真正，可能会包含重定向地址

### 4.2 请求与响应

HTTP 请求组成：请求行、消息报头、请求正文。

HTTP 响应组成：状态行、消息报头、响应正文。

![](http://cdn.jinyueyue.cn/15482432911160.jpg)

> tips
> 请求头中如果有`:`表示该参数是`http2`的请求头信息。
> 在做爬虫的时记得修改请求头中的来源`Referer`，和用户标识 `User-Agent`，防止被人发现是爬虫。

#### 4.2.1 常用的请求报头

- Accept：请求报头域用于指定客户端接受哪些类型的信息。eg:Accept:image/gif，Accept:text/ htmlAccept-Charset 请求报头域用于指定客户端接受的字符集。Accept-Encoding:Accept-Encoding 请求报 头域类似于 Accept，但是它是用于指定可接受的内容编码。

- Accept-Language：请求报头域类似于 Accept，但是它是用于指定一种自然语言。

- Authorization：请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服 务器的响应代码为 401(未授权)，可以发送一个包含 Authorization 请求报头域的请求，要求服务器对其进 行验证。

- Host：请求报头域主要用于指定被请求资源的 Internet 主机和端口号，它通常从 HTTP URL 中提取出来的，发 送请求时，该报头域是必需的。

- User-Agent：请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。

#### 4.2.2 常用的响应报头

- Location：响应报头域用于重定向接受者到一个新的位置。Location 响应 报头域常用在更换域名的时候。

- Server：响应报头域包含了服务器用来处理请求的软件信息。与 User- Agent 请求报头域是相对应的。

- WWW-Authenticate：响应报头域必须被包含在 401(未授权的)响应消息 中，客户端收到 401 响应消息时候，并发送 Authorization 报头域请求服 务器对其进行验证时，服务端响应报头就包含该报头域。

#### 4.2.3 常用的实体报文

在请求和响应中都可以发送一个实体，一个实体由实体报头和实体正文组成，实体报头定义了是否有实体正文和请求所标识的资源元信息。

常用的实体报文有：

- Content-Encoding：实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的 附加内容的编码，因而要获得 Content-Type 报头域中所引用的媒体类型，必须采用相应的解码 机制。

- Content-Language：实体报头域描述了资源所用的自然语言。

- Content-Length：实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。

- Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型。

- Last-Modified：实体报头域用于指示资源的最后修改日期和时间。

- Expires：实体报头域给出响应过期的日期和时间。

### 4.3 请求方法

我们平时用到的请求方式其实只有 GET，POST，OPTIONS，因为正常开发中有 GET，POST 就够了，但是请求方式其实还有很多种。

**完整的请求方式：**

- GET：请求获取 Request-URI 所标识的资源（查）
- POST：在 Request-URI 所标识的资源后附加新的数据（改）
- PUT：请求服务器存储一个资源，并用 Request-URI 作为其标识（增）
- DELETE：请求服务器删除 Request-URI 所标识的资源（删）
- OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求，OPTIONS 属于预请求，一般跨域的时候会出现。
- CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器
- HEAD：请求获取由 Request-URI 所标识的资源的响应消息报头
- TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断

在我们平时开发中，其实 GET 和 POST 都会使用，但是并没有明确区分，有的时候会使用 GET，有的时候会使用 POST，其实 GET 和 POST 还是有一些区别的。大部分人应该都知道 GET 请求会将参数携带到请求 url 后面，POST 不会，这只是其中一个差别而已，其实还有很多区别：

**如：**

- GET 请求浏览器回退是无害的，但是 POST 会重新发送请求
- GET 产生的地址会被收藏，但是 POST 不会
- GET 会被浏览器主动缓存，而 POST 的不会，需要手动设置
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式
- GET 请求的参数会被完整保留到历史记录里，POST 参数不会保存
- GET 请求在 url 中传送的参数有长度限制，POST 没有
- 对参数的数据类型，GET 只接受 ASCII 字符，POST 没有限制
- GET 参数会暴露在 url 中，不要放敏感信息
- GET 参数通过 url 传递，POST 通过 request body 中

### 4.4 HTTP 状态码

- 1xx - 请求已接收，继续处理
- 2xx - 表示处理成功，如 200
  - 200：客户端请求成功
  - 206：客户端发送了一个带有 Range 的 GET 请求头，服务器完成了他（video，audio）
- 3xx - 需要重定向，浏览器直接跳转
  - 301：已经转移到新的 url
  - 302：临时转移到了新的 url
  - 304：缓存，也被称为本地重定向
- 4xx - 客户端请求错误，如 404
  - 400：客户端有语法错误
  - 401：请求未授权（参数和方式可能错误）
  - 403：资源禁止被访问
  - 404：资源不存在
- 5xx - 服务端错误
  - 500：服务器错误
  - 503：服务器宕机或者过载

## 5. Cookie 和 Session（待补充）

Session 一直存在服务器中

cookie 在用户首次登录时，由服务端生成，并添加到浏览器中，浏览器后续请求时，将获取到的 cookie 添加到请求头中，服务器取到 cookie 之后进行登录验证

## 6. HTTP 缓存（待补充）

浏览器缓存可以放到内存中，也可以放到硬盘中

缓存的优点：

- 减少网络请求，减少带宽消耗
- 减少相应延迟

## 7. HTTPS

HTTPS 使用不对称加密，不对称加密中加密手段和解密手段是不可逆的。还有一个对称加密，加密手段和解密手段是可逆的。

HTTPS 使用 TLS 协议，TLS 协议分为四个子协议：握手协议，密钥配置切换协议（公钥，私钥），应用数据协议（数据如何处理），报警协议（检测证书是否过期，过期之后如何通知站长）。

名词解释：

数字证书：由 CA 签发

CA：数字证书签发机构

## 8. HTTP 2.0

- 使用二进制格式传输，更加高效，更加紧凑。
- 对报头进行压缩，降低开销
- 多路复用（linux 中网络编程的一个手段），一个网络连接实现并发传输
- 服务器主动推送，减少请求延迟
- 默认使用加密

> 将 HTTPS 和 HTTP1.1 进行整合，默认加密。目前大部分网站正在向 HTTP2.0 迁移。

> HTTP2.0 默认是加密的，所以访问网页的时候，协议默认是 https，端口号默认是 443。

1 字节是 8 个比特位

## 9. HTTP 和反向代理

正向代理：本地服务器访问外网服务器，中间使用代理服务器去做代理，客户机访问代理服务器，代理服务器然后访问外网服务器。

反向代理：客户机在外网，访问的服务器在内网中，我们客户机不能直接访问服务器，反向代理给服务器做代理，让客户机可以访问外网的服务器。（nginx）

反向代理的作用：

- 加密，SSL 加速（节省 tomcat 加密的操作）
- 负载均衡
- 缓存静态内容（将反向代理当成一个静态资源服务器，速度快）
- 压缩
- 减速上传（百度云上传下载限速）
- 安全（服务器在内网，如果有黑客想攻击内网服务器，必须首先攻破反向代理）
- 外网发布

nginx 配置反向代理：

在 nginx.conf 中 server 代码块之上。

![](http://cdn.jinyueyue.cn/15484057919879.jpg)

在 server 代码块之中配置对应的反向代理

![](http://cdn.jinyueyue.cn/15484060314659.jpg)
