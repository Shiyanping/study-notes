(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{59:function(a,t,r){"use strict";r.r(t);var e=r(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"函数式编程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程","aria-hidden":"true"}},[a._v("#")]),a._v(" 函数式编程")]),r("p",[a._v("JavaScript 本身并不是面向对象的语言，核心的本质是"),r("code",[a._v("function")]),a._v("，最初的 JavaScript 中并没有 "),r("code",[a._v("class")]),a._v("等")]),r("h2",{attrs:{id:"编程思维"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编程思维","aria-hidden":"true"}},[a._v("#")]),a._v(" 编程思维")]),r("p",[a._v("范畴论")]),r("p",[a._v("用数学的思维驱动我们写代码，函数式编程不是传统的棉线对象编程，也不是用函数来编程。主旨在于将复杂的函数合成简单的函数，运算过程尽量写成一系列嵌套的函数调用。")]),r("p",[a._v("JavaScript 是披着 C 外衣的 Lisp。")]),r("p",[a._v("随着 React 的高阶函数而逐步升温。")]),r("p",[a._v("没有"),r("code",[a._v("if...else")]),a._v("，没有"),r("code",[a._v("switch...case")]),a._v("。只用“表达式”，不用“语句”。")]),r("p",[a._v("函数时一等公民，函数与其他数据类型一样，处于平等地位，可以赋值给别的变量，也可以作为参数，传入另外一个函数，或者作为别的函数的返回值。")]),r("p",[a._v("所有的变量只能被赋值一次，函数也是一样。")]),r("h2",{attrs:{id:"核心概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#核心概念","aria-hidden":"true"}},[a._v("#")]),a._v(" 核心概念")]),r("h3",{attrs:{id:"纯函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#纯函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 纯函数")]),r("p",[a._v("对于相同的输入，永远会得到相同的输出。")]),r("h3",{attrs:{id:"函数柯里化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数柯里化","aria-hidden":"true"}},[a._v("#")]),a._v(" 函数柯里化")]),r("p",[a._v("传递给函数一部分参数，后续其他的作为返回值返回。将函数进行拆分。")]),r("p",[r("img",{attrs:{src:"http://cdn.jinyueyue.cn/15471234039053.jpg",alt:""}})]),r("h3",{attrs:{id:"偏应用函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#偏应用函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 偏应用函数")]),r("p",[a._v("bind")]),r("p",[a._v("柯里化就是偏函数的一个应用")]),r("h3",{attrs:{id:"高阶函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 高阶函数")]),r("p",[a._v("函数当参数，把传入的函数做一个封装，然后返回这个封装的函数，达到更高程度的抽象")]),r("h3",{attrs:{id:"尾递归调用优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#尾递归调用优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 尾递归调用优化")]),r("p",[a._v("爆栈的原因就是因为会保留栈内的执行堆栈的过程记录。")]),r("p",[a._v("正常的递归：")]),r("p",[r("img",{attrs:{src:"http://cdn.jinyueyue.cn/15471258663634.jpg",alt:""}})]),r("p",[a._v("尾递归：对递归进行优化\n"),r("img",{attrs:{src:"http://cdn.jinyueyue.cn/15471249444370.jpg",alt:""}})]),r("p",[a._v("问题：死循环与递归的区别")]),r("p",[a._v("递归与尾递归，尾递归与尾优化")]),r("h2",{attrs:{id:"库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#库","aria-hidden":"true"}},[a._v("#")]),a._v(" 库")]),r("p",[a._v("名词：FRP")]),r("p",[a._v("RxJS")]),r("p",[a._v("underscore.js")]),r("p",[a._v("lodash")]),r("h2",{attrs:{id:"应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用场景","aria-hidden":"true"}},[a._v("#")]),a._v(" 应用场景")]),r("p",[a._v("编写公用库时尽量使用函数式编程。")])])}],!1,null,null,null);t.default=s.exports}}]);